<html>
  <head>
  </head>
  <body id="mybody">
    <canvas id="myCanvas" width="600" height="600" style="border: 1px solid #000000;">
    </canvas>

    <script src="collision.js" type="text/javascript"></script>

    <script>

      document.getElementById("myCanvas").requestPointerLock = document.getElementById("myCanvas").requestPointerLock ||
               document.getElementById("myCanvas").mozRequestPointerLock ||
               document.getElementById("myCanvas").webkitRequestPointerLock;
      // Ask the browser to lock the pointer
      document.getElementById("myCanvas").requestPointerLock();

      // Ask the browser to release the pointer
      document.exitPointerLock = document.exitPointerLock ||
             document.mozExitPointerLock ||
             document.webkitExitPointerLock;
      // document.exitPointerLock();

      document.getElementById("myCanvas").onclick = function() {
        document.getElementById("myCanvas").requestPointerLock();
      }

      document.addEventListener("mousemove",function(event){
        movementX = event.movementX;
      });

      var c = document.getElementById("myCanvas");
      var ctx = c.getContext("2d");
      var playerThickness = 10;
      var movementY = false;
      var movementX = false;
      var ShadowballSoundEffect = "SHA-dowball.wav";
      var bopSound = "bop.wav";
      var canvasWidth = 600;
      var canvasHeight = 600;
      var centerPoint = {x: canvasWidth/2, y: canvasHeight/2};
      // var bopSound = "";

      function createPongBall(yPositionInit, xPositionInit){
        var myRectangle = {colorR: Math.floor( Math.random() * 255 ),
          colorG: Math.floor( Math.random() * 255 ),
          colorB: Math.floor( Math.random() * 255 ),
          height: 10,
          width: 10,
          yPos: Math.floor( Math.random() * 300 ) + 50,
          xPos: Math.floor( Math.random() * 700 ) + 50,
          yIncrease: true,
          xIncrease: true,
          speedX: 1,
          speedY: 2,
          tangible: true,
          speedMultiplyer: Math.floor( Math.random() * 1 )+1,
          lastHitBy: {},
          needsToBeRemoved: false
        };

        var randomTangibility = Math.floor(Math.random() * 2);
        // if(randomTangibility == 1){
        //   myRectangle.tangible = false;
        // } else {
        //   myRectangle.tangible = true;
        // }
        return myRectangle;
      }

      function rotatePoint(pointX, pointY, angle, newPointX, newPointY){

        var newPoint = {};
        newPoint.x = newPointX;
        newPoint.y = newPointY;

        var cosin = Math.cos(angle*Math.PI/180);
        var sin = Math.sin(angle*Math.PI/180);

        newPoint.x -= pointX;
        newPoint.y -= pointY;

        var xNew = newPoint.x * cosin - newPoint.y * sin;
        var yNew = newPoint.x * sin + newPoint.y * cosin;

        newPoint.x = xNew + pointX;
        newPoint.y = yNew + pointY;

        return newPoint;
      }

      function createPowerUp(){

      }

      function createPlayer(xPosition, yPosition, rotation){
        var myNewPlayer = {
          colorR: Math.floor( Math.random() * 255 ),
          colorG: Math.floor( Math.random() * 255 ),
          colorB: Math.floor( Math.random() * 255 ),
          yPos: yPosition,
          xPos: xPosition,
          newXPos: xPosition,
          newYPos: yPosition,
          size: 80,
          angle: 90,
          visible: true,
          destroyed: false,
          movingDown: true,
          powerups: [],
          rotation: 0
          };

        if(rotation){
          myNewPlayer.rotation = rotation;
        }
        return myNewPlayer;
      }

      var polygon1 = [{x:10, y:0}, {x:10, y:80}, {x:20, y:80}, {x:20,y:0}]
      var polygon2 = [{x:36, y:398}, {x:36, y:408}, {x:46, y:408}, {x:46,y:398}]
      function checkCollision(polygon1, polygon2){

        var sideToCompare = 1;
        for(var side = 0; side < polygon1.length; side++){

          var slopeOfSide = (polygon1[sideToCompare].y - polygon1[side].y) / (polygon1[sideToCompare].x - polygon1[side].x);
          var inverseSlopeOfSide = -1/slopeOfSide;
          var midPointOfSide1 = {x: (polygon1[sideToCompare].y + polygon1[side].y)/2, y: (polygon1[sideToCompare].x + polygon1[side].x)/2};

          //f(x) = slopeOfSidex + unknown
          var unknown = midPointOfSide1.y - midPointOfSide1.x*inverseSlopeOfSide;

          // console.log("Slope: " + slopeOfSide);
          // console.log("Inverse Slope: " + inverseSlopeOfSide);
          // console.log("Midpoint: " + midPointOfSide1.x + ", " + midPointOfSide1.y);
          // console.log("Equation for Projection: f(x)=" + inverseSlopeOfSide + "x" + " + " + unknown);

          var highestXForPolygon1 = undefined;
          var lowestXForPolygon1 = undefined;
          for(var i = 0; i < polygon1.length; i++){
            if(inverseSlopeOfSide == Number.POSITIVE_INFINITY || inverseSlopeOfSide == Number.NEGATIVE_INFINITY){
              var newPoint = {x: polygon2[i].y};
            } else if (inverseSlopeOfSide == 0){
              var newPoint = {x: polygon1[i].x};
            } else {
              var unknown2 = polygon1[i].y - polygon1[i].x*slopeOfSide;
              var newPoint = {x: (unknown2 - unknown) / (inverseSlopeOfSide-slopeOfSide)};
            }

            if(newPoint.x > highestXForPolygon1 || typeof highestXForPolygon1 == 'undefined'){
              highestXForPolygon1 = newPoint.x;
            }
            if(newPoint.x < lowestXForPolygon1 || typeof lowestXForPolygon1 == 'undefined'){
              lowestXForPolygon1 = newPoint.x;
            }
          }
          var highestXForPolygon2 = undefined;
          var lowestXForPolygon2 = undefined;
          for(var i = 0; i < polygon2.length; i++){
            if(inverseSlopeOfSide == Number.POSITIVE_INFINITY || inverseSlopeOfSide == Number.NEGATIVE_INFINITY){
              var newPoint = {x: polygon2[i].y};
            } else if (inverseSlopeOfSide == 0){
              var newPoint = {x: polygon2[i].x};
            } else {
              var unknown2 = polygon2[i].y - polygon2[i].x*slopeOfSide;
              var newPoint = {x: (unknown2 - unknown) / (inverseSlopeOfSide-slopeOfSide)};
            }
            if(newPoint.x > highestXForPolygon2 || typeof highestXForPolygon2 == 'undefined'){
              highestXForPolygon2 = newPoint.x;
            }
            if(newPoint.x < lowestXForPolygon2 || typeof lowestXForPolygon2 == 'undefined'){
              lowestXForPolygon2 = newPoint.x;
            }
          }

          if(lowestXForPolygon2 > highestXForPolygon1 && lowestXForPolygon1 < highestXForPolygon2){
            return false;
          }

          // console.log("Lowest Polygon1X: ");
          // console.log(lowestXForPolygon1);
          // console.log("Highest Polygon1X: ");
          // console.log(highestXForPolygon1);
          // console.log("Lowest Polygon2X: ");
          // console.log(lowestXForPolygon2);
          // console.log("Highest Polygon2X: ");
          // console.log(highestXForPolygon2);

          sideToCompare++;
          if(sideToCompare >= polygon1.length){
            sideToCompare = 0;
          }
        }

        sideToCompare = 1;
        for(var side = 0; side < polygon2.length; side++){

          var slopeOfSide = (polygon2[sideToCompare].y - polygon2[side].y) / (polygon2[sideToCompare].x - polygon2[side].x);
          var inverseSlopeOfSide = -1/slopeOfSide;
          var midPointOfSide1 = {x: (polygon2[sideToCompare].y + polygon2[side].y)/2, y: (polygon2[sideToCompare].x + polygon2[side].x)/2};

          //f(x) = slopeOfSidex + unknown
          var unknown = midPointOfSide1.y - midPointOfSide1.x*inverseSlopeOfSide;

          // console.log("Slope: " + slopeOfSide);
          // console.log("Inverse Slope: " + inverseSlopeOfSide);
          // console.log("Midpoint: " + midPointOfSide1.x + ", " + midPointOfSide1.y);
          // console.log("Equation for Projection: f(x)=" + inverseSlopeOfSide + "x" + " + " + unknown);

          var highestXForPolygon1 = undefined;
          var lowestXForPolygon1 = undefined;

          for(var i = 0; i < polygon1.length; i++){
            var newPoint = {};

            if(inverseSlopeOfSide == Number.POSITIVE_INFINITY || inverseSlopeOfSide == Number.NEGATIVE_INFINITY){
              newPoint.x = polygon1[i].y;
            } else if (inverseSlopeOfSide == 0){
              newPoint.x = polygon1[i].x;
            } else {
              var unknown2 = polygon1[i].y - polygon1[i].x*slopeOfSide;
              newPoint.x = (unknown2 - unknown) / (inverseSlopeOfSide-slopeOfSide);
            }

            if(newPoint.x > highestXForPolygon1 || typeof highestXForPolygon1 == 'undefined'){
              highestXForPolygon1 = newPoint.x;
            }
            if(newPoint.x < lowestXForPolygon1 || typeof lowestXForPolygon1 == 'undefined'){
              lowestXForPolygon1 = newPoint.x;
            }
          }
          var highestXForPolygon2 = undefined;
          var lowestXForPolygon2 = undefined;
          for(var i = 0; i < polygon2.length; i++){
            var newPoint
            if(inverseSlopeOfSide == Number.POSITIVE_INFINITY || inverseSlopeOfSide == Number.NEGATIVE_INFINITY){
              newPoint = {x: polygon2[i].y};
            } else if (inverseSlopeOfSide == 0){
              newPoint = {x: polygon2[i].x};
            } else {
              var unknown2 = polygon2[i].y - polygon2[i].x*slopeOfSide;
              newPoint = {x: (unknown2 - unknown) / (inverseSlopeOfSide-slopeOfSide)};
            }
            if(newPoint.x > highestXForPolygon2 || typeof highestXForPolygon2 == 'undefined'){
              highestXForPolygon2 = newPoint.x;
            }
            if(newPoint.x < lowestXForPolygon2 || typeof lowestXForPolygon2 == 'undefined'){
              lowestXForPolygon2 = newPoint.x;
            }
          }

          if(lowestXForPolygon1 > highestXForPolygon2 && lowestXForPolygon2 < highestXForPolygon1){
            return false;
          }

          // console.log("Lowest Polygon1X: ");
          // console.log(lowestXForPolygon1);
          // console.log("Highest Polygon1X: ");
          // console.log(highestXForPolygon1);
          // console.log("Lowest Polygon2X: ");
          // console.log(lowestXForPolygon2);
          // console.log("Highest Polygon2X: ");
          // console.log(highestXForPolygon2);

          sideToCompare++;
          if(sideToCompare >= polygon2.length){
            sideToCompare = 0;
          }
        }
        return true;
      }

      var pongBalls = [];
      var players = [];
      var borders = [];
      var obstacles = [];

      for(var i = 0; i < 1; i++){
        pongBalls.push(createPongBall(100, 10));
      }

      players.push(createPlayer(10, 0, 90));
      players.push(createPlayer(canvasWidth/2, 0, 90));
      players.push(createPlayer(canvasWidth-10, 0, 90));
      var controlledCharacter = players[0];

      window.setInterval(function(){


        for(var i = 0; i < pongBalls.length; i++){

          var xReversed = false;
          var yReversed = false;
          var collisionWithPlayer = false;

          if(pongBalls[i].yIncrease){
            pongBalls[i].yPos += pongBalls[i].speedY;
          } else {
            pongBalls[i].yPos -= pongBalls[i].speedY;
          }
          if(pongBalls[i].yPos+pongBalls[i].height >= canvasHeight|| pongBalls[i].yPos <= 0){
            pongBalls[i].speedY = -pongBalls[i].speedY;
            // yReversed = true;
          }

          if(pongBalls[i].xIncrease){
            pongBalls[i].xPos += pongBalls[i].speedX;
          } else {
            pongBalls[i].xPos -= pongBalls[i].speedX;
          }
          if(pongBalls[i].xPos+pongBalls[i].width >= canvasWidth || pongBalls[i].xPos <= 0){
            pongBalls[i].speedX = -pongBalls[i].speedX;
            // pongBalls[i].needsToBeRemoved = true;
          }

          var ballTopLeft = [pongBalls[i].xPos, pongBalls[i].yPos];
          var ballTopRight = [pongBalls[i].xPos + pongBalls[i].width, pongBalls[i].yPos];
          var ballBottomLeft = [pongBalls[i].xPos, pongBalls[i].yPos + pongBalls[i].height];
          var ballBottomRight = [pongBalls[i].xPos + pongBalls[i].width, pongBalls[i].yPos + pongBalls[i].height];

          var ball = [{x:ballTopLeft[0], y:ballTopLeft[1]}, {x:ballBottomLeft[0], y:ballBottomLeft[1]}, {x:ballBottomRight[0], y:ballBottomRight[1]}, {x:ballTopRight[0], y:ballTopRight[1]}];

          for(var eachPlayer = 0; eachPlayer < players.length; eachPlayer++){

            var MAXBOUNCEANGLE = (45/180 + players[eachPlayer].rotation/180) * Math.PI;
            var relativeIntersectY = 0;

            if(pongBalls[i].speedY == 0){
              pongBalls[i].speedY = 1;
            }
            if(pongBalls[i].speedX == 0){
              pongBalls[i].speedX = 1;
            }

            var playerTopLeft = [players[eachPlayer].xPos, players[eachPlayer].yPos];
            var playerTopRight = [players[eachPlayer].xPos + playerThickness, players[eachPlayer].yPos];
            var playerBottomLeft = [players[eachPlayer].xPos, players[eachPlayer].yPos + players[eachPlayer].size];
            var playerBottomRight = [players[eachPlayer].xPos + playerThickness, players[eachPlayer].yPos + players[eachPlayer].size];

            var player = [{x:playerTopLeft[0], y:playerTopLeft[1]}, {x:playerBottomLeft[0], y:playerBottomLeft[1]}, {x:playerBottomRight[0], y:playerBottomRight[1]}, {x:playerTopRight[0], y:playerTopRight[1]}];

            if(checkCollision(ball, player)){
              collisionWithPlayer = true;
            }

            // if(areaOfPlayer >= areaOfRectangleWithBall1 + areaOfRectangleWithBall2 + areaOfRectangleWithBall3 + areaOfRectangleWithBall4){
            //   if(pongBalls[i].tangible){
            //     // collisionWithPlayer = true;
            //     // relativeIntersectY = (players[eachPlayer].yPos+(players[eachPlayer].size/2)) - (ballCenter[1] + ballBottomLeft[1]);
            //     // var normalizedRelativeIntersectionY = (relativeIntersectY/(players[eachPlayer].size/2));
            //     // var bounceAngle = normalizedRelativeIntersectionY * MAXBOUNCEANGLE;
            //     //  console.log(bounceAngle);
            //     // pongBalls[i].speedX = pongBalls[i].speedXMultiplyer*Math.cos(bounceAngle);
            //     pongBalls[i].speedX = -pongBalls[i].speedX;
            //     pongBalls[i].speedY = -pongBalls[i].speedY;
            //     // pongBalls[i].speedY = pongBalls[i].speedYMultiplyer*-Math.sin(bounceAngle);
            //     //pongBalls[i].xPos = playerTopRight[0]+1;
            //     // console.log(pongBalls[i].xPos);
            //   } else {
            //     var snd = new Audio(ShadowballSoundEffect);
            //     // snd.play();
            //   }
            // }

            if(collisionWithPlayer){
              xReversed = true;
              yReversed = true;

              pongBalls[i].lastHitBy = players[eachPlayer];
              var snd = new Audio(bopSound);
              // snd.play();
            }
          }
        }

        var newPongBalls = [];
        for(var i = 0; i < pongBalls.length; i++){
          if(!pongBalls[i].needsToBeRemoved){
            newPongBalls.push(pongBalls[i]);
          }
        }

        //drawing functionality
        ctx.fillStyle = "#FFFFFF";
        ctx.clearRect(0, 0, canvasWidth, canvasHeight);

        for(var i = 0; i < newPongBalls.length; i++){
          ctx.fillStyle = "rgb(" + pongBalls[i].colorR + "," + pongBalls[i].colorG + "," + pongBalls[i].colorB + ")";
          ctx.fillRect(pongBalls[i].xPos, pongBalls[i].yPos, pongBalls[i].height, pongBalls[i].width);
        }

        for(var i = 0; i < players.length; i++){
          ctx.strokeStyle = "rgb(" + players[i].colorR + "," + players[i].colorG + "," + players[i].colorB + ")";
          ctx.beginPath();
          ctx.moveTo(players[i].xPos, players[i].yPos);

          var newPoint = rotatePoint(players[i].xPos, players[i].yPos, players[i].rotation, players[i].xPos+players[i].size, players[i].yPos);

          players[i].newXPos = newPoint.x;
          players[i].newYPos = newPoint.y;

          ctx.lineTo(players[i].newXPos, players[i].newYPos);
          ctx.lineWidth = playerThickness;
          ctx.stroke();
          ctx.closePath();

          if(movementX != 0){
            var Angle = Math.atan2(controlledCharacter.newYPos - controlledCharacter.yPos, controlledCharacter.newXPos - controlledCharacter.xPos);
            controlledCharacter.xPos += Math.cos(Angle) * movementX;
            controlledCharacter.yPos += Math.sin(Angle) * movementX;
          }
          //ctx.fillRect(players[i].yPos, players[i].xPos, players[i].length, playerThickness);
        }

        pongBalls = newPongBalls;
        movementX = 0;

      }, .01666);
    </script>
  </body>
</html>
